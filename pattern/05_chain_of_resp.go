package pattern

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

//"fmt"

/*
	1) Применимость:
		* Обработка запросов: Паттерн Цепочка обязанностей применяется, когда программа содержит несколько объектов, способных обработать запросы, но заранее неизвестно, какой запрос придёт и какой обработчик понадобится. Это позволяет организовать обработку запросов последовательно через цепочку обработчиков.
		* Последовательные проверки: Подходит для систем, где необходимо выполнять проверки или фильтрации последовательно. Например, система приёма онлайн-заказов с аутентификацией пользователей и проверкой данных заказа.
		* Динамическая перестройка цепочки: Используется, когда набор объектов, способных обработать запрос, должен задаваться динамически. Можно легко добавить или убрать звенья цепи, не изменяя структуру программы.
		* Обработка событий в GUI: В интерфейсах графических приложений для обработки событий, таких как нажатие кнопок, когда события передаются по цепочке компонентов до тех пор, пока не найдётся обработчик.

	2) Плюсы и минусы:
		Плюсы:
			+ Уменьшение зависимости: Паттерн снижает зависимость между клиентом и обработчиками, улучшая модульность и управляемость кода.
			+ Принцип единственной обязанности: Каждому обработчику назначается только одна обязанность, что делает код более читабельным и поддерживаемым.
			+ Принцип открытости/закрытости: Легко добавлять новые обработчики без изменения существующих классов.
			+ Гибкость и динамичность: Цепочку можно динамически перестраивать, добавляя или убирая обработчики.
		Минусы:
			- Неопределённый обработчик: Запрос может остаться необработанным, если ни один из обработчиков не сможет его обработать.
			- Отладка и тестирование: Усложнение структуры программы может затруднить отладку и тестирование цепочки.

	3) Реальные примеры использования на практике:
		* Система приёма онлайн-заказов: В системе приёма онлайн-заказов проверка аутентификации пользователя, валидации данных заказа, фильтрация массовых отправок формы и кэширование формы заказа могут быть реализованы как цепочка обязанностей.
		* GUI системы: В графических интерфейсах событийные обработки, такие как нажатие кнопок и передача событий, могут быть реализованы с помощью паттерна Цепочка обязанностей.
		* Обработка событий в поддержке клиентов: В службе поддержки клиентов запросы могут проходить через автоответчик, оператора первого уровня и инженера, пока не найдётся тот, кто сможет обработать запрос.
	4) Как связан с другими паттернами
		* Команда: Команда устанавливает косвенную одностороннюю связь от отправителей к получателям, тогда как Цепочка обязанностей передаёт запрос последовательно через цепочку потенциальных получателей.
		* Посредник: Посредник устраняет прямую связь между отправителями и получателями, заставляя их взаимодействовать через себя.
		* Наблюдатель: Наблюдатель передаёт запрос всем заинтересованным получателям одновременно, но позволяет им динамически подписываться и отписываться от оповещений.
		* Компоновщик: Цепочку обязанностей часто используют вместе с Компоновщиком для передачи запросов от дочерних компонентов к их родителям.
		* Декоратор: И Цепочка обязанностей, и Декоратор используют принцип рекурсивного выполнения операций через серию связанных объектов, но в Цепочке обработчики могут прерывать дальнейшую передачу запросов.
*/

type Handler interface {
	setNext(handler Handler)
	handler(requst string) string
}

type BaseHandler struct {
	next Handler
}

func (h *BaseHandler) setNext(handler Handler) {
	h.next = handler
}

func (h *BaseHandler) handler(requst string) (result string) {
	if h.next != nil {
		return h.next.handler(requst)
	}
	return "Requst not handled"
}

type HandlerGet struct {
	BaseHandler
}

func (h *HandlerGet) handler(requst string) (result string) {
	if requst == "GET" {
		return "HandlerGet обработал запрос"
	}
	return h.BaseHandler.handler(requst)
}

type HandlerPost struct {
	BaseHandler
}

func (h *HandlerPost) handler(requst string) (resula string) {
	if requst == "POST" {
		return "HandlerPost обработал этот запрос"
	}
	return h.BaseHandler.next.handler(requst)
}

// func main() {
// 	hp := HandlerPost{}
// 	hg := HandlerGet{}

// 	hp.setNext(&hg)

// 	fmt.Println(hp.handler("POST"))

// }
