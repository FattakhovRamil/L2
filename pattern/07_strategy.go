package pattern

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

/*
	1) Применимость: Паттерн Стратегия используется в случаях, когда необходимо иметь возможность варьировать поведение объекта во время выполнения программы, подставляя различные алгоритмы.
    Это особенно полезно, когда у объекта есть множество похожих методов, которые отличаются только деталями реализации. Проблемы, которые решает паттерн Стратегия:
        * Многообразие алгоритмов: Если в приложении используются различные алгоритмы, которые должны выполняться в зависимости от условий, паттерн позволяет легко подменять их на лету.
        * Упрощение кода: Разделение кода алгоритмов на отдельные классы уменьшает размер основного класса, делая его более читабельным и управляемым.
        * Изоляция изменений: Изменения в алгоритмах не затрагивают основной класс, что уменьшает риск внесения ошибок и упрощает командную работу.

	2) Плюсы и минусы:
		Плюсы:
            + Горячая замена алгоритмов: Возможность динамически менять алгоритмы во время выполнения программы.
            + Изоляция кода: Алгоритмы изолируются в отдельные классы, что упрощает их поддержку и тестирование.
            + Принцип открытости/закрытости: Новые стратегии можно добавлять без изменения существующего кода контекста.
            + Отказ от наследования: Переход от наследования к делегированию позволяет гибко изменять поведение объекта.
		Минусы:
            - Усложнение программы: Увеличение числа классов усложняет архитектуру программы.
            - Необходимость знания клиентом: Клиент должен понимать различия между стратегиями, чтобы выбрать подходящую.

	3) Реальные примеры использования на практике:
		* Навигационные системы: В приложениях-навигаторах, которые должны поддерживать различные способы прокладки маршрутов (автомобильные, пешие, на общественном транспорте и т.д.), паттерн Стратегия позволяет легко добавлять новые алгоритмы прокладки маршрутов без изменения основного кода навигатора.
        * Анализ данных: В системах анализа данных, где различные алгоритмы обработки данных могут быть применены к одним и тем же исходным данным в зависимости от контекста.
        * Игры: В играх, где поведение персонажей (например, стратегия атаки или обороны) может изменяться в зависимости от ситуации.
        * Финансовые приложения: В приложениях для торговли, где разные стратегии торговли (например, агрессивная или консервативная) могут быть применены в зависимости от рыночных условий.
	4) Как связан с другими паттернами
		* Мост: Как и Стратегия, использует композицию для делегирования работы другим объектам. Однако Мост акцентируется на разделении абстракции и реализации для независимого изменения.
        * Состояние: Схож с паттерном Стратегия, но сосредоточен на изменении поведения объекта при смене его состояния. В Состоянии конкретные состояния могут сами переключать контекст, тогда как в Стратегии этого не происходит.
        * Шаблонный метод: Работает на уровне классов, предоставляя частично реализованный алгоритм, тогда как Стратегия позволяет менять логику отдельных объектов.
        * Команда: Превращает запросы на выполнение действия в объекты, тогда как Стратегия позволяет заменять различные способы выполнения одного действия.
*/

// import "fmt"

type AlgoStrategy interface {
	execute([]int)
}

type BubbleSort struct {
}

func (a *BubbleSort) execute(arr []int) {
	len := len(arr)
	for i := 0; i < len-1; i++ {
		for j := 0; j < len-i-1; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}

type QuickSort struct {
}

func (a *QuickSort) execute(arr []int) {
	a.quickSort(arr, 0, len(arr)-1)
}

func (a *QuickSort) quickSort(arr []int, low, high int) {
	if low < high {
		var p int
		p = a.partition(arr, low, high)
		a.quickSort(arr, low, p-1)
		a.quickSort(arr, p+1, high)
	}
}

func (a *QuickSort) partition(arr []int, low, high int) int {
	pivot := arr[high]
	i := low
	for j := low; j < high; j++ {
		if arr[j] < pivot {
			arr[i], arr[j] = arr[j], arr[i]
			i++
		}
	}
	arr[i], arr[high] = arr[high], arr[i]
	return i
}

type ArrSort struct {
	strategy AlgoStrategy
}

func (a *ArrSort) setAlgoritm(strategy AlgoStrategy) {
	a.strategy = strategy
}

func (a *ArrSort) doSort(arr []int) {
	a.strategy.execute(arr)
}

// func main() {
// 	bubbleSort := &BubbleSort{}

// 	algoSort := &ArrSort{strategy: bubbleSort}
// 	slices := []int{1,3,2,4,5,7,6,8,9,10}
// 	algoSort.doSort(slices)
// 	fmt.Println(slices)

// 	quickSort := &QuickSort{}

// 	algoSort.setAlgoritm(quickSort)

// 	slices1 := []int{1,3,2,4,5,7,6,8,9,10}
// 	algoSort.doSort(slices1)
// 	fmt.Println(slices1)
// }
