package pattern

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы,а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern
*/

/*
	1) Применимость:
    Фасад используется в ситуациях, когда нужно упростить взаимодействие с сложной системой классов, библиотекой или фреймворком. Проблема заключается в том,
     что работа с такими системами требует инициализации большого количества объектов и учета их взаимозависимостей, что усложняет код и делает его трудным для понимания и поддержки.
    * Упрощение интерфейса: Предоставляет простой и понятный интерфейс к сложной системе, скрывая ее внутреннюю сложность.
    * Снижение зависимости: Изолирует клиентский код от деталей реализации, что уменьшает зависимость между клиентом и сложной подсистемой.
    * Улучшение читабельности и поддержки кода: Делает бизнес-логику более понятной и легкой для поддержки, так как детали реализации скрыты за фасадом.

	2) Плюсы и минусы:
        Плюсы:
        + Упрощение взаимодействия: Фасад предоставляет упрощенный интерфейс к сложной системе, делая ее использование более интуитивным.
        + Снижение зависимости: Изолирует клиентский код от сложной подсистемы, что облегчает замену или обновление подсистемы.
        + Повышение читабельности: Делает код более понятным и структурированным, так как скрывает детали реализации.
        + Повышение повторного использования: Способствует повторному использованию кода за счет более четкой организации подсистем.
        Минусы:
        - Ограниченный доступ к функциональности: Фасад может не предоставлять полный доступ ко всем возможностям сложной системы, ограничиваясь только наиболее важными функциями.
        - Создание божественного объекта: Риск превращения фасада в "божественный объект", который слишком много знает и контролирует слишком многое, что нарушает принципы SOLID.

	3) Реальные примеры использования на практике:
    	* Приложения для социальных сетей: Программа, заливающая видео на платформы социальных сетей, может использовать фасад для работы с библиотекой сжатия видео. Вместо работы с десятками классов библиотеки, клиентский код может использовать простой метод encode(filename, format).
    	* Системы заказа и доставки: В онлайн-магазинах, фасад может предоставлять единый интерфейс для создания заказа, обработки платежей и организации доставки, скрывая сложные взаимодействия между различными отделами и системами.
    	* Графические фреймворки: В играх и графических приложениях, фасад может упростить взаимодействие с графическими библиотеками, предоставляя простой интерфейс для рендеринга, обработки текстур и анимаций.

	4) Как связан с другими паттернами
    	* Адаптер (Adapter): Фасад предоставляет новый интерфейс к системе, тогда как адаптер переиспользует существующий интерфейс. Адаптер оборачивает один класс, а фасад — целую подсистему.
    	* Абстрактная фабрика (Abstract Factory): Может использоваться вместо фасада для скрытия платформо-зависимых классов, предоставляя интерфейсы для создания объектов.
   		* Посредник (Mediator): Посредник и фасад организуют работу множества классов. Посредник централизует общение между компонентами, а фасад предоставляет упрощенный интерфейс к подсистеме.
    	* Легковес (Flyweight): Фасад может быть сделан одиночкой (Singleton), так как часто нужен только один объект-фасад.
    	* Заместитель (Proxy): Заместитель похож на фасад тем, что замещает сложную подсистему, но имеет тот же интерфейс, что и служебный объект, благодаря чему их можно взаимозаменять.
*/

//"fmt"

// Интерфейс Inventory определяет методы, которые должны быть реализованы всеми классами подсистемы.
// Это методы для проверки наличия товара и получения его цены.
type Inventory interface {
	HasItem(string) bool
	GetItemPrice(string) int
}

// StoreA реализует интерфейс Inventory. Этот класс представляет первый магазин.
// Реализация класса подсистемы
type StoreA struct {
}

// Метод HasItem проверяет наличие товара в первом магазине.
func (s *StoreA) HasItem(item string) bool {
	if item == "itemA" {
		return true
	}
	return false
}

// Метод GetItemPrice возвращает цену товара из первого магазина.
func (s *StoreA) GetItemPrice(item string) int {
	if item == "itemA" {
		return 100
	}
	return 0
}

// StoreB реализует интерфейс Inventory. Этот класс представляет второй магазин.
type StoreB struct {
}

// Метод HasItem проверяет наличие товара во втором магазине.
func (s *StoreB) HasItem(item string) bool {
	if item == "itemB" {
		return true
	}
	return false
}

// Метод GetItemPrice возвращает цену товара из второго магазина.
func (s *StoreB) GetItemPrice(item string) int {
	if item == "itemB" {
		return 200
	}
	return 0
}

// Shop представляет собой фасад для взаимодействия с несколькими магазинами.
type Shop struct {
	stores []Inventory
}

// NewShop создаёт и возвращает новый экземпляр Shop, инициализируя его списком магазинов.
func NewShop() *Shop {
	return &Shop{
		stores: []Inventory{&StoreA{}, &StoreB{}},
	}
}

// Метод Found проверяет наличие товара в любом из магазинов.
func (s *Shop) Found(item string) bool {
	for _, store := range s.stores {
		if store.HasItem(item) {
			return true
		}
	}
	return false
}

// Метод GetPrice возвращает цену товара из магазина, в котором он найден.
func (s *Shop) GetPrice(item string) int {
	for _, store := range s.stores {
		if store.HasItem(item) {
			return store.GetItemPrice(item)
		}
	}
	return 0
}

// Клиент
// func main() {
//     shop := NewShop()

//     item := "itemA"

//     if shop.Found(item) {
//         fmt.Printf("Item %s found, price: %d\n", item, shop.GetPrice(item))
//     } else {
//         fmt.Printf("Item %s not found\n", item)
//     }

//     item = "itemB"

//     if shop.Found(item) {
//         fmt.Printf("Item %s found, price: %d\n", item, shop.GetPrice(item))
//     } else {
//         fmt.Printf("Item %s not found\n", item)
//     }

//     item = "itemC"

//     if shop.Found(item) {
//         fmt.Printf("Item %s found, price: %d\n", item, shop.GetPrice(item))
//     } else {
//         fmt.Printf("Item %s not found\n", item)
//     }
// }
