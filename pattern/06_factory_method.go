package pattern

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
	1) Применимость:
		* Неопределённые типы и зависимости объектов: Паттерн используется, когда типы и зависимости объектов, с которыми должен работать код, неизвестны заранее. Например, при разработке системы логистики, когда изначально поддерживаются только автомобили, но позже требуется добавить поддержку морских судов.
		* Изоляция кода производства продуктов: Паттерн позволяет отделить код производства продуктов от остального кода, что упрощает его расширение и модификацию. Это решает проблему жесткой привязки к конкретным классам продуктов, что позволяет легко добавлять новые типы транспорта, такие как самолеты или поезда.
		* Расширяемость фреймворков и библиотек: Пользователи фреймворков могут расширять функциональность через наследование и создавать объекты новых классов. Например, создание круглыx кнопок вместо стандартных прямоугольных в UI-фреймворке.
		* Экономия системных ресурсов: Паттерн может использоваться для повторного использования уже созданных объектов, что особенно полезно при работе с ресурсоемкими объектами, такими как подключения к базе данных.

	2) Плюсы и минусы:
		Плюсы:
			+ Отделение конкретных классов продуктов: Избавляет основной код от привязки к конкретным классам продуктов, улучшая модульность и поддерживаемость.
			+ Упрощение поддержки кода: Выделение кода производства продуктов в одно место упрощает его поддержку и модификацию.
			+ Легкость добавления новых продуктов: Упрощает процесс добавления новых типов продуктов, реализуя принцип открытости/закрытости.
			+ Гибкость и расширяемость: Позволяет легко расширять функциональность, не изменяя основной код.
		Минусы:
			- Увеличение числа классов: Может привести к созданию большого числа классов, так как для каждого нового продукта необходимо создавать свой подкласс создателя.
			- Сложность архитектуры: Усложнение архитектуры программы за счет добавления новых уровней абстракции.

	3) Реальные примеры использования на практике:
		* Системы логистики: В программах управления грузовыми перевозками, где могут использоваться разные виды транспорта, такие как грузовики, суда и поезда. Фабричный метод позволяет динамически создавать соответствующие транспортные средства без изменения основного кода.
		* Кросс-платформенные UI элементы: В приложениях, где требуется поддержка различных операционных систем, фабричный метод используется для создания элементов интерфейса, таких как кнопки, в зависимости от платформы (Windows, HTML и т.д.).
		* Фреймворки и библиотеки: В UI-фреймворках, где пользователи могут определять свои собственные типы элементов, такие как кнопки или панели, путём расширения стандартных классов фреймворка.
		* Ресурсоёмкие системы: В системах, где необходимо повторное использование тяжелых объектов, таких как подключения к базам данных, фабричный метод может возвращать уже существующие объекты из кэша.
	4) Как связан с другими паттернами
		* Абстрактная фабрика: Многие архитектуры начинают с применения Фабричного метода и эволюционируют в сторону более сложных паттернов, таких как Абстрактная фабрика, Прототип или Строитель.
		* Итератор: Фабричный метод может использоваться вместе с Итератором, чтобы подклассы коллекций могли создавать подходящие итераторы.
		* Прототип: В отличие от Прототипа, который не опирается на наследование, но требует сложной инициализации, Фабричный метод построен на наследовании и не требует сложной инициализации.
		* Шаблонный метод: Фабричный метод нередко является частью большого класса с Шаблонными методами, где фабричный метод используется для создания продуктов, а Шаблонный метод для управления их жизненным циклом.
*/

//"fmt"

// Интерфейс Vacuum, который все конкретные пылесосы должны реализовать
type Vacuum interface {
	Clean() string
}

// Интерфейс фабрики CreateVacuum
type CreateVacuum interface {
	CreateVacuum() Vacuum
}

// Структура VacuumAuto, представляющая автоматический пылесос
type VacuumAuto struct{}

func (v *VacuumAuto) Clean() string {
	return "VacuumAuto is working"
}

// Фабрика для создания автоматических пылесосов
type VacuumAutoFactory struct{}

func (f *VacuumAutoFactory) CreateVacuum() Vacuum {
	return &VacuumAuto{}
}

// Структура VacuumHand, представляющая ручной пылесос
type VacuumHand struct{}

func (v *VacuumHand) Clean() string {
	return "VacuumHand is working"
}

// Фабрика для создания ручных пылесосов
type VacuumHandFactory struct{}

func (f *VacuumHandFactory) CreateVacuum() Vacuum {
	return &VacuumHand{}
}

// func main() {
// 	// Создание фабрики автоматических пылесосов
// 	autoFactory := &fabricmethod.VacuumAutoFactory{}
// 	autoVacuum := autoFactory.CreateVacuum()
// 	fmt.Println(autoVacuum.Clean()) // Вывод: VacuumAuto is working

// 	// Создание фабрики ручных пылесосов
// 	handFactory := &fabricmethod.VacuumHandFactory{}
// 	handVacuum := handFactory.CreateVacuum()
// 	fmt.Println(handVacuum.Clean()) // Вывод: VacuumHand is working
// }
