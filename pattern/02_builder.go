package pattern

/*
	Реализовать паттерн «строитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Builder_pattern
*/

/*
	1) Применимость: Строитель это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один
	 и тот же код строительства для получения разных представлений объектов.
		* Создание сложных объектов: Когда объект требует сложной пошаговой инициализации множества полей и вложенных объектов. Строитель позволяет выделить эту инициализацию в отдельный процесс, избегая громоздких конструкторов.
		* Разные представления объекта: Когда необходимо создать разные представления одного и того же объекта. Строитель позволяет использовать один и тот же процесс строительства для получения различных версий объекта.
		* Изоляция сложного кода: Строитель изолирует сложный код сборки продукта от его основной бизнес-логики, упрощая поддержку и изменение кода.
		* Избегание телескопических конструкторов: Когда использование конструкторов с множеством параметров приводит к неудобству и сложности в коде.

	2) Плюсы и минусы:
		Плюсы:
		+ Пошаговое создание объектов: Позволяет создавать продукты поэтапно, улучшая контроль над процессом.
		+ Повторное использование кода: Один и тот же код строительства можно использовать для создания различных продуктов.
		+ Изоляция сложного кода: Код сборки продукта отделен от его бизнес-логики, что упрощает поддержку и модификацию.
		+ Гибкость и расширяемость: Легко добавлять новые типы строителей для создания различных представлений объектов.
		Минусы:
		- Усложнение кода: Введение дополнительных классов может усложнить структуру программы.
		- Зависимость от конкретных классов строителей: Клиентский код может быть жестко привязан к конкретным классам строителей, если интерфейс строителя не включает метод получения результата.

	3) Реальные примеры использования на практике:
		* Сборка пользовательских заказов: В e-commerce платформах, таких как Amazon или Shopify, пользователи могут конфигурировать свои заказы (например, сборка компьютера из различных компонентов). Паттерн Строитель помогает пошагово настраивать продукт по запросам клиента.
	Пример: Конфигураторы для настройки персональных компьютеров на сайтах Dell и HP используют паттерн Строитель для создания кастомизированных заказов на основе пользовательских выборов.
		* Конструкторы интерфейсов: Платформы для разработки пользовательских интерфейсов, такие как Android Studio или Unity, используют паттерн Строитель для создания сложных UI-компонентов (например, диалоговых окон, форм ввода) с различными элементами и настройками.
	Пример: В Android SDK паттерн Строитель используется для создания объектов AlertDialog, где разработчики могут пошагово добавлять заголовок, сообщение, кнопки и другие элементы.
		* Создание игровых объектов: В гейм-девелопменте, движки типа Unreal Engine и Unity используют паттерн Строитель для создания сложных игровых объектов и уровней. Это позволяет разработчикам пошагово настраивать различные аспекты объектов, такие как физика, анимация, текстуры и поведение.
	Пример: В Unity, паттерн Строитель используется для создания и настройки игровых объектов через скрипты, что упрощает управление сложными игровыми структурами.
		* Конфигурация HTTP-запросов: Библиотеки для работы с HTTP-запросами, такие как Retrofit в Android, используют паттерн Строитель для конфигурирования запросов. Это включает установку URL, параметров, заголовков, методов запроса и тела запроса.
	Пример: В Retrofit, создание и настройка HTTP-запросов осуществляется через билдеры, позволяя разработчикам гибко управлять параметрами запроса.
		* Конфигурирование файлов и объектов: В системах управления конфигурациями, таких как Ansible или Puppet, паттерн Строитель используется для пошагового создания файлов конфигураций с различными параметрами, обеспечивая точность и гибкость.
	Пример: В Ansible плейбуках можно использовать билдеры для создания конфигураций серверов, что упрощает управление различными настройками и параметрами в инфраструктуре.

	4) Как связан с другими паттернами
		* Фабричный метод: Многие архитектуры начинаются с применения Фабричного метода и эволюционируют в сторону Строителя, когда требуется более гибкое создание сложных объектов.
		* Абстрактная фабрика: Абстрактная фабрика специализируется на создании семейств связанных продуктов, тогда как Строитель фокусируется на создании одного сложного объекта пошагово.
		* Прототип: Используется для создания копий объектов, а Строитель для создания новых объектов с нуля, пошагово.
		* Мост: Паттерн Строитель может быть реализован в виде Моста, где директор играет роль абстракции, а строители — реализации.
*/

//"fmt"

// Director управляет процессом создания клавиатуры с использованием объектов Builder.
type Director struct {
}

// makeKeyboard инициирует процесс создания клавиатуры с использованием заданного билдера.
func (d *Director) makeKeyboard(builder Builder) {
	builder.ChooseForm() // Выбор формы клавиатуры
	builder.Backlight()  // Добавление подсветки
}

// Builder определяет интерфейс для создания частей объекта Keyboard.
type Builder interface {
	ChooseForm()         // Выбор формы клавиатуры
	Backlight()          // Добавление подсветки
	getResult() Keyboard // Получение результата сборки клавиатуры
}

// Keyboard представляет собой продукт, который создается Builder'ом.
type Keyboard struct {
	form  string // Форма клавиатуры
	light bool   // Наличие подсветки
}

// MechanicalKeyboardBuilder конкретная реализация Builder для механических клавиатур.
type MechanicalKeyboardBuilder struct {
	mechKeyboard Keyboard // Объект клавиатуры, который собирается
}

// ChooseForm задает форму для механической клавиатуры.
func (b *MechanicalKeyboardBuilder) ChooseForm() {
	b.mechKeyboard.form = "mech"
}

// Backlight добавляет подсветку к механической клавиатуре.
func (b *MechanicalKeyboardBuilder) Backlight() {
	b.mechKeyboard.light = true
}

// getResult возвращает собранную механическую клавиатуру.
func (b *MechanicalKeyboardBuilder) getResult() Keyboard {
	return b.mechKeyboard
}

// MembraneKeyboardBuilder конкретная реализация Builder для мембранных клавиатур.
type MembraneKeyboardBuilder struct {
	membKeyboard Keyboard // Объект клавиатуры, который собирается
}

// ChooseForm задает форму для мембранной клавиатуры.
func (b *MembraneKeyboardBuilder) ChooseForm() {
	b.membKeyboard.form = "tip tip"
}

// Backlight не добавляет подсветку к мембранной клавиатуре.
func (b *MembraneKeyboardBuilder) Backlight() {
	b.membKeyboard.light = false
}

// getResult возвращает собранную мембранную клавиатуру.
func (b *MembraneKeyboardBuilder) getResult() Keyboard {
	return b.membKeyboard
}

// func main() {
// Создание директора
// 	director := Director{}
// Создание и сборка механической клавиатуры
// 	mechanicalBuilder := MechanicalKeyboardBuilder{}
// 	director.makeKeyboard(&mechanicalBuilder)
// 	fmt.Println(mechanicalBuilder.getResult())
// Создание и сборка мембранной клавиатуры
// 	membraneBuilder := MembraneKeyboardBuilder{}
// 	director.makeKeyboard(&membraneBuilder)
// 	fmt.Println(membraneBuilder.getResult())
// }
